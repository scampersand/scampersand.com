@import "susy";
@import "partials/normalize";
@import "partials/hacks";

/**
 - Reset
 */

blockquote, h1, h2, h3, h4, h5, h6, p, ul, li, fieldset {
    margin: 0;
    padding: 0;
}

img {
    max-width: 100%;

    /* auto height preserves ratio when the image is scaled. */
    height: auto;
}

input, textarea {
    width: 100%;
}

input[type="submit"] {
    width: 33%;
}

/**
 - Vertical layout
 */

/* Force main to take at least the height of the viewport,
 * especially for applying a background color on the landing.
 * See http://stackoverflow.com/a/17555766/347386
 * but we're using body height 100% because nesting min-height doesn't work, see
 * http://stackoverflow.com/q/16043519/347386
 * The SO answer says using body height 100% will "leave a gap beneath the fold,
 * which is usually undesirable" but I couldn't find anything wrong.
 */
html, body {
    height: 100%;
}

main {
    position: relative;
    min-height: 100%;  // of body
    padding-bottom: 12em;  // sufficient for footer
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
}

@import "partials/nav";
@import "partials/cards";
@import "partials/color";
@import "partials/type";
@import "partials/scale";

// https://github.com/philipwalton/flexbugs#3-min-height-on-a-flex-container-wont-apply-to-its-flex-items
.flex-ie-hack {
    display: flex;
    flex-direction: column;
}

.flex-vertical-center {
    display: flex;
    flex-flow: column;
    justify-content: center;
    padding-top: 2em;  // 2x nav top
    padding-bottom: 2em;  // maintains centering
    min-height: 100vh;  // in case calc() doesn't work
    min-height: calc(100vh - 54px);  // 54px is mobile nav header
    @media screen and (min-width: 30em) {
        // 57.75px is desktop nav header.
        // This doesn't change at 65em when the menu items are revealed.
        min-height: calc(100vh - 57.75px);
    }
}

.flex-item-wrapper {
    /*
    h1.landing and p.landing both have max-width constraints. Normally
    div.section-container would still occupy the full width available and the
    auto margins on right and left would center the block on the page. In other
    words, the width of div.section-container shouldn't be determined by its
    content but rather by the available space.

    However when div.section-container is a flex item--meaning the direct child
    of a flex box--then the calculations changes. Instead of occupying width
    available, its width corresponds to the width of its h1 and p content. The
    result is that the susy container appears indented rather than flush left
    aligned with the top bar content.

    The first workaround was to put flexbox inside the susy container, see
    55e067d. However that results in bad rendering on iphone 4 and old android
    browser.

    This new workaround adds div.flex-item-wrapper which seems to iron out the
    cross-width calculation on the flex box. This way div.section-container is
    no longer a flex item itself and spans the intended width.
    */
}

body.landing main {
    padding-bottom: 0px;  // no footer on landing
}

/**
 - Columns
 */

$susy: (
    // debug: (image: show),
    global-box-sizing: border-box,
    columns: 8,
);

@include border-box-sizing;

main {
    // from 16 base font size
    @include container(97.5em);
}

div.section-container {
    // from 16 base font size
    @include container(75em);

    padding-left: 1em;
    padding-right: 1em;

    @media (min-width: 30em) {
        padding-left: 1.5em;
        padding-right: 1.5em;
    }
}

div.proj-name {
    @media (min-width: 48em) {
        display: inline-block;
        width: span(6);
    }
}

div.proj-skills {
    @media (min-width: 48em) {
        display: inline-block;
    }
}

div.proj-solution {
    @include span(full);
}

div.proj-problem,
div.solution-text,
div.proj-image {
    @media (min-width: 48em) {
        @include span(5);
    }
}

div.solution-features {
    @media (min-width: 48em) {
        @include span(2 wide last);
    }
}

div.contact-form {
    @media (min-width: 48em) {
        @include span(4);
    }
}

div.contact-map {
    position: relative;
    .overlay {
        position: absolute;
        height: 100%;
        width: 100%;
        background: transparent;
    }
}

div.ref-services {
    display: none;
    @media (min-width: 48em) {
        display: block;
        @include span(4);
    }
}

div.contact-location,
div.contact-social,
div.ref-social {
    @media (min-width: 48em) {
        @include span(4 last);
    }
}

p.intro {
    @media (min-width: 56em) {
        @include span(5);
    }
}

.cards {
    display: block;
    @media (min-width: 56em) {
        display: flex;
        flex-flow: row wrap;
        align-items: stretch;  /* default */
        justify-content: space-between;  /* equals gutter() */
    }
}

.card {
    display: block;
    margin-bottom: gutter();
    /* gutter() is a percentage which doesn't work on Firefox for vertical
     * margin on a flex item. This hack applies a different margin on Firefox
     * and Microsoft Edge. https://bugzilla.mozilla.org/show_bug.cgi?id=958714
     */
    @include only-firefox {  // partials/_hacks.scss
        margin-bottom: 29.531px;  // from Chrome's computed result
    }
    @include only-edge {  // partials/_hacks.scss
        margin-bottom: 29.531px;  // from Chrome's computed result
    }
    @media (min-width: 56em) {
        width: span(4);
    }
}

.bio-list,
.services-list,
.work-list {
    @extend .cards;
}

.services-item,
.work-item {
    @extend .card;
}

.bio-item {
    @extend .card;
    display: flex;  // so .bio-text can fill to bottom
    flex-direction: column;
}

.bio-item,
.work-item {
    /* bio images should always fill their container.
     * This allows img sizes attribute to affect what image
     * in the srcset is fetched, without affecting the
     * presentation. Possibly this should be a handled
     * globally somehow.
     */
    img {
        width: 100%;
    }
}

.work-title {
    text-transform: uppercase;
}

.bio-photo,
.work-photo {
    position: relative;
}

.work-overlay {
    position: absolute;
    left: 1.5rem;
    bottom: 1.5rem;
}

.bio-overlay {
    position: absolute;
    width: 100%;
    height: 22%;
    bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: center;
}


.bio-text {
    flex-grow: 1;  // fill gray to bottom
}

/* clear any floated children in galleries */
div.section-sub:after {
    content: '';
    clear: both;
    display: block;
}
